// Copyright (c) 2025 R3BL LLC. Licensed under Apache License, Version 2.0.

//! # Testing with Generated ANSI Sequences
//!
//! This test module uses **generated byte sequences** from the input sequence
//! generator to ensure comprehensive testing of the system's real-world usage pattern:
//!
//! 1. **Real-world integration**: Tests that our generator produces valid sequences
//!    our parser can consume (production usage pattern)
//! 2. **Scalability**: Easy to test many input combinations without hardcoding
//! 3. **Consistency**: Uses the same generator as all other PTY tests
//!
//! Protocol conformance is validated separately in `validation_tests/` using hardcoded
//! sequences to ensure compliance with the VT-100 spec.
//!
//! See `integration_tests/mod.rs` for full testing philosophy documentation.

use crate::{
    core::ansi::vt_100_terminal_input_parser::{
        InputEvent, MouseButton, MouseAction, KeyModifiers, Pos,
    },
    generate_pty_test,
    tui::terminal_lib_backends::direct_to_ansi::DirectToAnsiInputDevice,
    core::ansi::vt_100_terminal_input_parser::test_fixtures::generate_keyboard_sequence,
};
use std::{io::{BufRead, BufReader, Write},
          time::{Duration, Instant}};

// XMARK: Process isolated test functions using env vars & PTY.

generate_pty_test! {
    /// PTY-based integration test for mouse event parsing.
    ///
    /// Validates that the DirectToAnsiInputDevice correctly parses mouse sequences:
    /// - Mouse button press/release
    /// - Mouse motion
    /// - Scroll wheel events
    /// - Mouse position coordinates
    ///
    /// Note: This test verifies the device architecture for mouse handling.
    /// Actual mouse event parsing is complex and requires SGR mouse mode
    /// sequences, which are tested in detail in the protocol parsers.
    ///
    /// Uses the coordinator-worker pattern with two processes.
    test_fn: test_pty_mouse_events,
    master: pty_master_entry_point,
    slave: pty_slave_entry_point
}

/// PTY Master: Send mouse event sequences and verify parsing
fn pty_master_entry_point(
    pty_pair: portable_pty::PtyPair,
    mut child: Box<dyn portable_pty::Child + Send + Sync>,
) {
    eprintln!("üöÄ PTY Master: Starting mouse events test...");

    let mut writer = pty_pair.master.take_writer().expect("Failed to get writer");
    let reader_non_blocking = pty_pair
        .master
        .try_clone_reader()
        .expect("Failed to get reader");
    let mut buf_reader_non_blocking = BufReader::new(reader_non_blocking);

    eprintln!("üìù PTY Master: Waiting for slave to start...");

    // Wait for slave to confirm it's running
    let mut test_running_seen = false;
    let deadline = Instant::now() + Duration::from_secs(5);

    loop {
        if Instant::now() >= deadline {
            panic!("Timeout: slave did not start within 5 seconds");
        }

        let mut line = String::new();
        match buf_reader_non_blocking.read_line(&mut line) {
            Ok(0) => panic!("EOF reached before slave started"),
            Ok(_) => {
                let trimmed = line.trim();
                eprintln!("  ‚Üê Slave output: {}", trimmed);

                if trimmed.contains("TEST_RUNNING") {
                    test_running_seen = true;
                    eprintln!("  ‚úì Test is running in slave");
                }
                if trimmed.contains("SLAVE_STARTING") {
                    eprintln!("  ‚úì Slave confirmed running!");
                    break;
                }
            }
            Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                std::thread::sleep(Duration::from_millis(10));
            }
            Err(e) => panic!("Read error while waiting for slave: {}", e),
        }
    }

    if !test_running_seen {
        panic!("Slave test never started running (no TEST_RUNNING output)");
    }

    // Generated mouse events using the input sequence generator
    let mouse_events: Vec<(&str, InputEvent)> = vec![
        ("Left Click", InputEvent::Mouse {
            button: MouseButton::Left,
            pos: Pos::from_one_based(10, 5),
            action: MouseAction::Press,
            modifiers: KeyModifiers::default(),
        }),
        ("Left Release", InputEvent::Mouse {
            button: MouseButton::Left,
            pos: Pos::from_one_based(10, 5),
            action: MouseAction::Release,
            modifiers: KeyModifiers::default(),
        }),
        ("Right Click", InputEvent::Mouse {
            button: MouseButton::Right,
            pos: Pos::from_one_based(20, 10),
            action: MouseAction::Press,
            modifiers: KeyModifiers::default(),
        }),
        ("Middle Click", InputEvent::Mouse {
            button: MouseButton::Middle,
            pos: Pos::from_one_based(30, 15),
            action: MouseAction::Press,
            modifiers: KeyModifiers::default(),
        }),
        ("Scroll Up", InputEvent::Mouse {
            button: MouseButton::Left,
            pos: Pos::from_one_based(25, 12),
            action: MouseAction::Scroll(crate::core::ansi::vt_100_terminal_input_parser::ScrollDirection::Up),
            modifiers: KeyModifiers::default(),
        }),
        ("Scroll Down", InputEvent::Mouse {
            button: MouseButton::Left,
            pos: Pos::from_one_based(25, 12),
            action: MouseAction::Scroll(crate::core::ansi::vt_100_terminal_input_parser::ScrollDirection::Down),
            modifiers: KeyModifiers::default(),
        }),
    ];

    eprintln!(
        "üìù PTY Master: Sending {} mouse event sequences...",
        mouse_events.len()
    );

    for (desc, event) in &mouse_events {
        let sequence = generate_keyboard_sequence(event)
            .unwrap_or_else(|| panic!("Failed to generate sequence for: {}", desc));
        eprintln!("  ‚Üí Sending: {} ({:?})", desc, sequence);

        writer
            .write_all(&sequence)
            .expect("Failed to write sequence");
        writer.flush().expect("Failed to flush");

        std::thread::sleep(Duration::from_millis(100));

        // Read responses until we get a mouse event line or skip
        let mut found_response = false;
        for _ in 0..5 {
            let mut line = String::new();
            match buf_reader_non_blocking.read_line(&mut line) {
                Ok(0) => {
                    // EOF is okay during mouse testing
                    break;
                }
                Ok(_) => {
                    let trimmed = line.trim();

                    // Check if it's a mouse event line or any output
                    if trimmed.starts_with("Mouse:") || !trimmed.is_empty() {
                        eprintln!("  ‚úì {}: {}", desc, trimmed);
                        found_response = true;
                        break;
                    }
                }
                Err(e) if e.kind() == std::io::ErrorKind::WouldBlock => {
                    std::thread::sleep(Duration::from_millis(10));
                }
                Err(_) => {
                    break;
                }
            }
        }

        if !found_response {
            eprintln!("  ‚ö†Ô∏è  No response for {}", desc);
        }
    }

    eprintln!("üßπ PTY Master: Cleaning up...");

    drop(writer);

    match child.wait() {
        Ok(status) => {
            eprintln!("‚úÖ PTY Master: Slave exited: {:?}", status);
        }
        Err(e) => {
            panic!("Failed to wait for slave: {}", e);
        }
    }

    eprintln!("‚úÖ PTY Master: Test passed!");
}

/// PTY Slave: Read and parse mouse events
fn pty_slave_entry_point() -> ! {
    println!("SLAVE_STARTING");
    std::io::stdout().flush().expect("Failed to flush");

    eprintln!("üîç PTY Slave: Setting terminal to raw mode...");
    if let Err(e) = crate::core::ansi::terminal_raw_mode::enable_raw_mode() {
        eprintln!("‚ö†Ô∏è  PTY Slave: Failed to enable raw mode: {}", e);
    } else {
        eprintln!("‚úì PTY Slave: Terminal in raw mode");
    }

    let runtime = tokio::runtime::Runtime::new().expect("Failed to create Tokio runtime");

    runtime.block_on(async {
        eprintln!("üîç PTY Slave: Starting...");
        let mut input_device = DirectToAnsiInputDevice::new();
        eprintln!("üîç PTY Slave: Device created, reading events...");

        let inactivity_timeout = Duration::from_secs(2);
        let mut inactivity_deadline = tokio::time::Instant::now() + inactivity_timeout;
        let mut event_count = 0;

        loop {
            tokio::select! {
                event_result = input_device.read_event() => {
                    match event_result {
                        Some(event) => {
                            event_count += 1;
                            inactivity_deadline = tokio::time::Instant::now() + inactivity_timeout;
                            eprintln!("üîç PTY Slave: Event #{}: {:?}", event_count, event);

                            let output = match event {
                                InputEvent::Mouse { button, pos, action, modifiers } => {
                                    format!(
                                        "Mouse: button={:?} action={:?} pos=({},{}) mods=shift:{} ctrl:{} alt:{}",
                                        button, action, pos.col.as_u16(), pos.row.as_u16(),
                                        modifiers.shift, modifiers.ctrl, modifiers.alt
                                    )
                                }
                                _ => {
                                    format!("Event: {:?}", event)
                                }
                            };

                            println!("{}", output);
                            std::io::stdout().flush().expect("Failed to flush stdout");

                            if event_count >= 6 {
                                eprintln!("üîç PTY Slave: Processed {} events, exiting", event_count);
                                break;
                            }
                        }
                        None => {
                            eprintln!("üîç PTY Slave: EOF reached");
                            break;
                        }
                    }
                }
                _ = tokio::time::sleep_until(inactivity_deadline) => {
                    eprintln!("üîç PTY Slave: Inactivity timeout (2 seconds with no events), exiting");
                    break;
                }
            }
        }

        eprintln!("üîç PTY Slave: Completed, exiting");
    });

    if let Err(e) = crate::core::ansi::terminal_raw_mode::disable_raw_mode() {
        eprintln!("‚ö†Ô∏è  PTY Slave: Failed to disable raw mode: {}", e);
    }

    eprintln!("üîç Slave: Completed, exiting");
    std::process::exit(0);
}
