// Copyright (c) 2025 R3BL LLC. Licensed under Apache License, Version 2.0.

//! Tests for ANSI parser error handling and robustness.
//!
//! This module tests the parser's ability to handle malformed sequences,
//! invalid parameters, incomplete sequences, and other error conditions
//! gracefully without crashing or corrupting state.
//!
//! ## Raw Byte Sequences Usage
//!
//! **Important**: This test module intentionally uses raw byte sequences
//! (e.g., `b"\x1b[L"`) instead of our type-safe builders ([`CsiSequence`],
//! [`EscSequence`], etc.) because:
//!
//! 1. **Malformed sequences cannot be created with type-safe enums** - The builders
//!    enforce valid parameter ranges and proper formatting
//! 2. **Testing parser robustness requires invalid input** - We need to test how the
//!    parser handles sequences that would never be generated by our type-safe code
//! 3. **Real-world robustness** - Applications must handle arbitrary PTY output from
//!    external processes that may contain malformed sequences
//!
//! This is the **only** test module where raw sequences are appropriate.
//! All other tests should use the type-safe builders for maintainability
//! and correctness.
//!
//! ## Error Handling Categories
//! - Malformed CSI sequences with invalid parameters
//! - Incomplete escape sequences
//! - Out-of-bounds values and boundary violations
//! - Invalid UTF-8 sequences and control characters
//! - Mixed valid/invalid sequence combinations
//! - Buffer overflow and performance stress scenarios
//! - VTE parser internal limit overflow (>16 params, >2 intermediates)
//!
//! [`CsiSequence`]: crate::CsiSequence
//! [`EscSequence`]: crate::EscSequence

use super::super::test_fixtures_vt_100_ansi_conformance::*;
use crate::{col, core::ansi::vt_100_pty_output_parser::CsiSequence, row, term_col,
            term_row};

/// Tests for malformed CSI sequence handling.
pub mod malformed_csi_sequences {
    use super::*;

    /// Note: Using type-safe `CsiSequence` builders (not raw bytes) because we're testing
    /// bounds clamping behavior with valid sequences that have out-of-bounds parameters.
    /// This differs from malformed sequence tests which need raw bytes for invalid
    /// syntax.
    #[test]
    fn test_invalid_cursor_position_parameters() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Send CSI sequences with invalid parameters
        let malformed_sequences: Vec<&[u8]> = vec![
            b"\x1b[999;999H", // Position far beyond buffer bounds
            b"\x1b[0;0H",     // Zero position (should clamp to 1,1)
            b"\x1b[-5;-10H",  // Negative positions
            b"\x1b[;H",       // Missing parameters
            b"\x1b[1;H",      // Missing second parameter
            b"\x1b[;1H",      // Missing first parameter
        ];

        for sequence in malformed_sequences {
            let _unused = ofs_buf.apply_ansi_bytes(sequence);

            // Cursor should remain within valid bounds
            assert!(
                ofs_buf.cursor_pos.row_index < row(10),
                "Cursor row out of bounds after sequence: {:?}",
                std::str::from_utf8(sequence).unwrap_or("invalid UTF-8")
            );
            assert!(
                ofs_buf.cursor_pos.col_index < col(10),
                "Cursor column out of bounds after sequence: {:?}",
                std::str::from_utf8(sequence).unwrap_or("invalid UTF-8")
            );
        }
    }

    #[test]
    fn test_invalid_sgr_parameters() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test SGR sequences with invalid parameters
        let malformed_sgr: Vec<&[u8]> = vec![
            b"\x1b[999m",              // Out-of-range SGR code
            b"\x1b[-1m",               // Negative SGR code
            b"\x1b[m",                 // Missing parameter (should default to reset)
            b"\x1b[38;5;999m",         // Invalid 256-color index
            b"\x1b[38;2;300;300;300m", // RGB values > 255
            b"\x1b[48;5;-1m",          // Negative background color
        ];

        for sequence in malformed_sgr {
            let _unused = ofs_buf.apply_ansi_bytes(sequence);

            // Parser should handle gracefully - no crash expected
            // Style state should remain valid
            let style = &ofs_buf.ansi_parser_support.current_style;
            // Basic validity check - style object should be accessible
            let _ = &style.attribs;
        }
    }

    #[test]
    fn test_incomplete_csi_sequences() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test incomplete sequences that might be split across buffer boundaries
        let incomplete_sequences: Vec<&[u8]> = vec![
            b"\x1b[",    // Just CSI introducer
            b"\x1b[2",   // Parameter without terminator
            b"\x1b[1;",  // Parameter with separator but no second param
            b"\x1b[1;2", // Parameters without command character
            b"\x1b[?",   // Private mode marker without rest
        ];

        for sequence in incomplete_sequences {
            let _unused = ofs_buf.apply_ansi_bytes(sequence);

            // Should not crash - VTE parser handles incomplete sequences
            // Write some text after to verify parser recovery
            let _unused = ofs_buf.apply_ansi_bytes("TEST");
        }
    }

    #[test]
    fn test_csi_with_excessive_parameters() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // CSI sequence with many parameters (stress test parameter parsing)
        let excessive_params = b"\x1b[1;2;3;4;5;6;7;8;9;10;11;12;13;14;15H";
        let _unused = ofs_buf.apply_ansi_bytes(excessive_params);

        // Should not crash and cursor should remain in bounds
        assert!(ofs_buf.cursor_pos.row_index < row(10));
        assert!(ofs_buf.cursor_pos.col_index < col(10));
    }

    #[test]
    fn test_unknown_csi_commands() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test unknown CSI command characters
        let unknown_commands: Vec<&[u8]> = vec![
            b"\x1b[1Q",   // Unknown command 'Q'
            b"\x1b[5X",   // Unknown command 'X'
            b"\x1b[?25Y", // Unknown private mode command 'Y'
            b"\x1b[>1Z",  // Unknown secondary DA command 'Z'
        ];

        for sequence in unknown_commands {
            let _unused = ofs_buf.apply_ansi_bytes(sequence);

            // Should handle gracefully and allow continued operation
            let _unused = ofs_buf.apply_ansi_bytes("OK");
        }
    }
}

/// Tests for malformed OSC sequence handling.
pub mod malformed_osc_sequences {
    use super::*;

    #[test]
    fn test_incomplete_osc_sequences() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test incomplete OSC sequences
        let incomplete_osc: Vec<&[u8]> = vec![
            b"\x1b]",        // Just OSC introducer
            b"\x1b]0",       // OSC code without separator
            b"\x1b]0;",      // OSC code with separator but no data
            b"\x1b]0;title", // OSC without terminator
        ];

        for sequence in incomplete_osc {
            let _unused = ofs_buf.apply_ansi_bytes(sequence);

            // Should not crash
            let _unused = ofs_buf.apply_ansi_bytes("RECOVERY");
        }
    }

    #[test]
    fn test_osc_with_invalid_codes() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test OSC sequences with invalid codes
        let invalid_osc: Vec<&[u8]> = vec![
            b"\x1b]999;data\x07", // Unknown OSC code
            b"\x1b]-1;data\x07",  // Negative OSC code
            b"\x1b]abc;data\x07", // Non-numeric OSC code
            b"\x1b];data\x07",    // Missing OSC code
        ];

        for sequence in invalid_osc {
            let _unused = ofs_buf.apply_ansi_bytes(sequence);

            // Should handle gracefully
            let _unused = ofs_buf.apply_ansi_bytes("CONTINUE");
        }
    }

    #[test]
    fn test_osc_with_malformed_parameters() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test OSC hyperlinks with malformed parameters
        let malformed_hyperlinks: Vec<&[u8]> = vec![
            b"\x1b]8;;\x07",                             // Empty URI
            b"\x1b]8;id=test\x07",                       // Missing URI
            b"\x1b]8;id=test;not-a-uri\x07",             // Invalid URI format
            b"\x1b]8;invalid-param;http://test.com\x07", // Malformed parameters
        ];

        for sequence in malformed_hyperlinks {
            let _unused = ofs_buf.apply_ansi_bytes(sequence);

            // Should handle gracefully without corrupting state
            let _unused = ofs_buf.apply_ansi_bytes("Link text");
        }
    }
}

/// Tests for invalid control characters and UTF-8 handling.
pub mod invalid_character_handling {
    use super::*;

    #[test]
    fn test_invalid_control_characters() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test invalid or unsupported control characters
        let invalid_controls: Vec<&[u8]> = vec![
            b"\x01", // SOH (Start of Header)
            b"\x02", // STX (Start of Text)
            b"\x7F", // DEL (Delete)
            b"\x80", // PAD (Padding Character) - C1 control
            b"\x9F", // APC (Application Program Command)
        ];

        for sequence in invalid_controls {
            let _unused = ofs_buf.apply_ansi_bytes(sequence);

            // Should not crash or corrupt state
            let _unused = ofs_buf.apply_ansi_bytes("TEST");
        }
    }

    #[test]
    fn test_mixed_valid_invalid_sequences() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Mix valid and invalid sequences
        let mixed_sequence = format!(
            "{}{}{}{}{}",
            "Valid text before",
            "\x1b[999;999H", // Invalid position
            "Text after invalid position",
            "\x1b[38;5;999m", // Invalid color
            "Text after invalid color"
        );

        let _unused = ofs_buf.apply_ansi_bytes(mixed_sequence);

        // Should handle mixture gracefully
        assert!(ofs_buf.cursor_pos.row_index < row(10));
        assert!(ofs_buf.cursor_pos.col_index < col(10));
    }

    #[test]
    fn test_rapid_malformed_sequence_stream() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Send many malformed sequences rapidly
        for _ in 0..50 {
            let malformed_batch = format!(
                "{}{}{}{}",
                "\x1b[999H",      // Invalid position
                "\x1b[999m",      // Invalid SGR
                "\x1b]999;x\x07", // Invalid OSC
                "X"               // Valid character
            );
            let _unused = ofs_buf.apply_ansi_bytes(malformed_batch);
        }

        // Should maintain stability under stress
        assert!(ofs_buf.cursor_pos.row_index < row(10));
        assert!(ofs_buf.cursor_pos.col_index < col(10));

        // Should still accept valid input
        let _unused = ofs_buf.apply_ansi_bytes("FINAL");
    }
}

/// Tests for boundary conditions and edge cases.
pub mod boundary_edge_cases {
    use super::*;

    /// Note: Testing VT100 spec compliance requires raw ANSI bytes because
    /// zero-parameter sequences ARE valid in the VT100 spec (treated as 1),
    /// but our type-safe API intentionally prevents zero-valued deltas to
    /// avoid the CSI zero bug. Raw bytes test the parser's VT100 compliance.
    #[test]
    fn test_zero_parameter_treated_as_one() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test VT100-compliant behavior: zero parameters are treated as 1
        // Using raw ANSI bytes since type-safe API prevents zero deltas
        let test_cases = vec![
            (
                "Cursor up by 0",
                "\x1b[0A",  // Raw ANSI: CSI 0 A
                term_row(nz(3)),
                term_col(nz(3)),
                row(1),
                col(2),
            ),
            (
                "Cursor down by 0",
                "\x1b[0B",  // Raw ANSI: CSI 0 B
                term_row(nz(3)),
                term_col(nz(3)),
                row(3),
                col(2),
            ),
            (
                "Cursor forward by 0",
                "\x1b[0C",  // Raw ANSI: CSI 0 C
                term_row(nz(3)),
                term_col(nz(3)),
                row(2),
                col(3),
            ),
            (
                "Cursor backward by 0",
                "\x1b[0D",  // Raw ANSI: CSI 0 D
                term_row(nz(3)),
                term_col(nz(3)),
                row(2),
                col(1),
            ),
        ];

        for (
            description,
            movement_cmd_bytes,
            start_row,
            start_col,
            expected_row,
            expected_col,
        ) in test_cases
        {
            // Reset cursor to known position for each test
            let _unused = ofs_buf.apply_ansi_bytes(format!(
                "{}",
                CsiSequence::CursorPosition {
                    row: start_row,
                    col: start_col
                }
            ));

            // Apply the zero-parameter movement command (raw ANSI bytes)
            let _unused = ofs_buf.apply_ansi_bytes(movement_cmd_bytes);

            // Per VT100 spec: parameter 0 is treated as 1 (minimum movement)
            assert_eq!(
                ofs_buf.cursor_pos.row_index, expected_row,
                "VT100 spec: {description} should move by 1 (row)"
            );
            assert_eq!(
                ofs_buf.cursor_pos.col_index, expected_col,
                "VT100 spec: {description} should move by 1 (col)"
            );
        }
    }

    #[test]
    fn test_maximum_parameter_values() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test with very large parameter values
        let large_params: Vec<&[u8]> = vec![
            b"\x1b[65535;65535H", // Maximum u16 values
            b"\x1b[32767A",       // Large cursor movement
            b"\x1b[999999m",      // Very large SGR code
        ];

        for sequence in large_params {
            let _unused = ofs_buf.apply_ansi_bytes(sequence);

            // Should clamp to valid ranges
            assert!(ofs_buf.cursor_pos.row_index < row(10));
            assert!(ofs_buf.cursor_pos.col_index < col(10));
        }
    }

    #[test]
    fn test_buffer_position_clamping() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test positions beyond buffer boundaries
        let beyond_bounds = vec![
            format!(
                "{}",
                CsiSequence::CursorPosition {
                    row: term_row(nz(50)),
                    col: term_col(nz(50))
                }
            ),
            format!(
                "{}",
                CsiSequence::CursorPosition {
                    row: term_row(nz(1)),
                    col: term_col(nz(100))
                }
            ),
            format!(
                "{}",
                CsiSequence::CursorPosition {
                    row: term_row(nz(100)),
                    col: term_col(nz(1))
                }
            ),
        ];

        for sequence in beyond_bounds {
            let _unused = ofs_buf.apply_ansi_bytes(sequence);

            // Positions should be clamped to buffer bounds
            assert!(
                ofs_buf.cursor_pos.row_index <= row(9), /* 0-based, so max is 9
                                                         * for 10-row buffer */
                "Row not clamped properly: {:?}",
                ofs_buf.cursor_pos
            );
            assert!(
                ofs_buf.cursor_pos.col_index <= col(9), /* 0-based, so max is 9
                                                         * for 10-col buffer */
                "Column not clamped properly: {:?}",
                ofs_buf.cursor_pos
            );
        }
    }
}

/// Tests for parser state recovery and resilience.
pub mod parser_resilience {
    use super::*;

    #[test]
    fn test_recovery_after_malformed_sequences() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Send malformed sequences followed by valid ones
        let recovery_test = format!(
            "{}{}{}{}{}",
            "Initial text",
            "\x1b[INVALID",      // Malformed escape
            "\x1b]999MALFORMED", // Malformed OSC
            "Recovery text",     // Should be processed normally
            CsiSequence::CursorPosition {
                row: term_row(nz(2)),
                col: term_col(nz(1))
            }
        );

        let _unused = ofs_buf.apply_ansi_bytes(recovery_test);

        // Should be able to continue processing after malformed input
        let _unused = ofs_buf.apply_ansi_bytes("Final test");

        // Parser should be in a valid state
        assert!(ofs_buf.cursor_pos.row_index < row(10));
        assert!(ofs_buf.cursor_pos.col_index < col(10));
    }

    #[test]
    fn test_partial_sequence_handling() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Simulate partial sequences arriving in separate chunks
        let partial_chunks: Vec<&[u8]> = vec![
            b"\x1b", // ESC alone
            b"[",    // [ to complete CSI introducer
            b"1",    // First parameter digit
            b"0",    // Second parameter digit
            b";",    // Parameter separator
            b"5",    // Second parameter
            b"H",    // Command character
        ];

        // Send chunks separately (simulating network/buffer splits)
        for chunk in partial_chunks {
            let _unused = ofs_buf.apply_ansi_bytes(chunk);
        }

        // Should eventually process complete sequence
        assert!(ofs_buf.cursor_pos.row_index < row(10));
        assert!(ofs_buf.cursor_pos.col_index < col(10));
    }

    #[test]
    fn test_state_corruption_prevention() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Try to corrupt parser state with adversarial input
        let adversarial_input = format!(
            "{}{}{}{}{}{}{}",
            "\x1b[s",            // Save cursor
            "\x1b[999;999H",     // Move to invalid position
            "\x1b[999m",         // Invalid SGR
            "\x1b]0;evil\x1b\\", // OSC with early terminator
            "\x1b[u",            // Restore cursor
            "\x1b[H",            // Home
            "State check"        // Normal text
        );

        let _unused = ofs_buf.apply_ansi_bytes(adversarial_input);

        // State should remain consistent
        assert!(ofs_buf.cursor_pos.row_index < row(10));
        assert!(ofs_buf.cursor_pos.col_index < col(10));

        // Should still respond to valid commands
        let move_sequence = format!(
            "{}",
            CsiSequence::CursorPosition {
                row: term_row(nz(3)),
                col: term_col(nz(3))
            }
        );
        let _unused = ofs_buf.apply_ansi_bytes(move_sequence);

        assert_eq!(ofs_buf.cursor_pos.row_index, row(2)); // 0-based
        assert_eq!(ofs_buf.cursor_pos.col_index, col(2)); // 0-based
    }
}

/// Tests for VTE parser internal limit handling (`ignore` parameter).
///
/// These tests specifically validate the `ignore` parameter functionality added to
/// [`performer.rs`]. The VTE parser sets `ignore = true` when its internal limits are
/// exceeded:
/// - More than 16 parameters in a CSI sequence
/// - More than 2 intermediate bytes in CSI/ESC sequences
///
/// According to industry best practices (Alacritty, kitty, st, GNOME VTE), terminals
/// should **discard the entire sequence** when these limits are exceeded, rather than
/// execute commands with truncated parameters.
///
/// See the [performer module docs] for detailed rationale and references.
///
/// [`performer.rs`]: super::super::super::performer
/// [performer module docs]: super::super::super::performer#malformed-sequences-and-the-ignore-parameter
pub mod vte_parser_limit_exceeded {
    use super::*;
    use crate::CharacterSet;

    #[test]
    fn test_csi_excessive_parameters_ignored() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Set cursor to known position
        let initial_pos = format!(
            "{}",
            CsiSequence::CursorPosition {
                row: term_row(nz(5)),
                col: term_col(nz(5))
            }
        );
        let _unused = ofs_buf.apply_ansi_bytes(initial_pos);
        assert_eq!(ofs_buf.cursor_pos.row_index, row(4));
        assert_eq!(ofs_buf.cursor_pos.col_index, col(4));

        // Send CSI sequence with many parameters (exceeds VTE's internal limit)
        // VTE will collect up to its limit, set ignore=true, and call csi_dispatch()
        // Our implementation should discard this entirely
        // Note: Using 50 params to ensure we exceed whatever VTE's actual limit is
        let excessive_params = b"\x1b[1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17;18;19;20;21;22;23;24;25;26;27;28;29;30;31;32;33;34;35;36;37;38;39;40;41;42;43;44;45;46;47;48;49;50H";
        let _unused = ofs_buf.apply_ansi_bytes(excessive_params);

        // Cursor should NOT have moved - sequence was discarded
        assert_eq!(
            ofs_buf.cursor_pos.row_index,
            row(4),
            "Cursor should not move when CSI sequence exceeds parameter limit"
        );
        assert_eq!(
            ofs_buf.cursor_pos.col_index,
            col(4),
            "Cursor should not move when CSI sequence exceeds parameter limit"
        );

        // Verify parser still works after ignored sequence
        let valid_move = format!(
            "{}",
            CsiSequence::CursorPosition {
                row: term_row(nz(2)),
                col: term_col(nz(2))
            }
        );
        let _unused = ofs_buf.apply_ansi_bytes(valid_move);
        assert_eq!(
            ofs_buf.cursor_pos.row_index,
            row(1),
            "Parser should recover and process valid sequences"
        );
        assert_eq!(
            ofs_buf.cursor_pos.col_index,
            col(1),
            "Parser should recover and process valid sequences"
        );
    }

    #[test]
    fn test_csi_excessive_intermediates_ignored() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Set cursor to known position
        let initial_pos = format!(
            "{}",
            CsiSequence::CursorPosition {
                row: term_row(nz(3)),
                col: term_col(nz(3))
            }
        );
        let _unused = ofs_buf.apply_ansi_bytes(initial_pos);
        assert_eq!(ofs_buf.cursor_pos.row_index, row(2));
        assert_eq!(ofs_buf.cursor_pos.col_index, col(2));

        // Send CSI sequence with too many intermediate bytes (>2)
        // Format: ESC [ intermediates... final_char
        // Using multiple '?' characters as intermediates (normally used for private
        // modes)
        let excessive_intermediates = b"\x1b[?>?>?>A"; // 4 intermediate bytes
        let _unused = ofs_buf.apply_ansi_bytes(excessive_intermediates);

        // Cursor should NOT have moved - sequence was discarded
        assert_eq!(
            ofs_buf.cursor_pos.row_index,
            row(2),
            "Cursor should not move when CSI has too many intermediates"
        );
        assert_eq!(
            ofs_buf.cursor_pos.col_index,
            col(2),
            "Cursor should not move when CSI has too many intermediates"
        );
    }

    #[test]
    fn test_esc_excessive_intermediates_ignored() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Get initial character set state (should be ASCII by default)
        let initial_charset = matches!(
            ofs_buf.ansi_parser_support.character_set,
            CharacterSet::Ascii
        );

        // Send ESC sequence with too many intermediate bytes
        // Normal: ESC ( 0 (select DEC graphics)
        // Excessive: ESC ( ( ( 0 (too many '(' intermediates)
        let excessive_intermediates = b"\x1b(((0";
        let _unused = ofs_buf.apply_ansi_bytes(excessive_intermediates);

        // Character set should NOT have changed - sequence was discarded
        let charset_after = matches!(
            ofs_buf.ansi_parser_support.character_set,
            CharacterSet::Ascii
        );
        assert_eq!(
            charset_after, initial_charset,
            "Character set should not change when ESC has too many intermediates"
        );
    }

    #[test]
    fn test_dcs_ignored_regardless_of_limits() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // DCS sequences are not implemented in the multiplexer, so they're ignored
        // whether well-formed or malformed. This test verifies that excessive parameters
        // in DCS don't cause crashes (hook() doesn't check ignore flag since all DCS
        // are ignored)

        // Send DCS with excessive parameters: ESC P params... data ESC \
        let dcs_excessive_params =
            b"\x1bP1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17;18;19;20;data\x1b\\";
        let _unused = ofs_buf.apply_ansi_bytes(dcs_excessive_params);

        // Should not crash - verify by sending valid text
        let _unused = ofs_buf.apply_ansi_bytes("TEXT");

        // Cursor should have advanced for the printable text
        assert!(
            ofs_buf.cursor_pos.col_index >= col(4),
            "Parser should continue working after ignored DCS"
        );
    }

    #[test]
    fn test_parser_recovery_after_ignore() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Send sequence that will be ignored, followed by valid sequences
        let mixed_sequence = format!(
            "{}{}{}",
            "\x1b[1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17;18;19;20;21;22;23;24;25;26;27;28;29;30;31;32;33;34;35;36;37;38;39;40;41;42;43;44;45;46;47;48;49;50H", /* Ignored */
            "Recovery text", // Should be processed
            CsiSequence::CursorPosition {
                row: term_row(nz(7)),
                col: term_col(nz(3))
            }  // Should work
        );

        let _unused = ofs_buf.apply_ansi_bytes(mixed_sequence);

        // Parser should have recovered and processed the valid cursor position
        assert_eq!(
            ofs_buf.cursor_pos.row_index,
            row(6),
            "Parser should recover and process valid sequences after ignored one"
        );
        assert_eq!(
            ofs_buf.cursor_pos.col_index,
            col(2),
            "Parser should recover and process valid sequences after ignored one"
        );
    }

    #[test]
    fn test_mixed_valid_and_ignored_sequences() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Interleave valid and ignored sequences
        let sequence = format!(
            "{}{}{}{}{}",
            CsiSequence::CursorPosition {
                row: term_row(nz(2)),
                col: term_col(nz(2))
            }, // Valid - should execute
            "\x1b[1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17;18;19;20;21;22;23;24;25;26;27;28;29;30;31;32;33;34;35;36;37;38;39;40;41;42;43;44;45;46;47;48;49;50H", /* Ignored */
            "TEXT",            // Valid text
            "\x1b[?>?>?>?>5A", // Ignored (excessive intermediates)
            CsiSequence::CursorPosition {
                row: term_row(nz(5)),
                col: term_col(nz(5))
            }  // Valid - should execute
        );

        let _unused = ofs_buf.apply_ansi_bytes(sequence);

        // Only the valid sequences should have executed
        // Final position should be (5,5) from last valid cursor position
        // (TEXT would have moved cursor but then final position overrides)
        assert_eq!(
            ofs_buf.cursor_pos.row_index,
            row(4),
            "Only valid sequences should execute, ignored ones discarded"
        );
        assert_eq!(
            ofs_buf.cursor_pos.col_index,
            col(4),
            "Only valid sequences should execute, ignored ones discarded"
        );
    }

    #[test]
    fn test_excessive_params_different_csi_commands() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test that ignore parameter works for different CSI command types
        // Using 50 params to ensure we exceed VTE's limit
        let test_cases: Vec<(&[u8], &str)> = vec![
            (
                b"\x1b[1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17;18;19;20;21;22;23;24;25;26;27;28;29;30;31;32;33;34;35;36;37;38;39;40;41;42;43;44;45;46;47;48;49;50H",
                "CUP (Cursor Position)",
            ),
            (
                b"\x1b[1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17;18;19;20;21;22;23;24;25;26;27;28;29;30;31;32;33;34;35;36;37;38;39;40;41;42;43;44;45;46;47;48;49;50A",
                "CUU (Cursor Up)",
            ),
            (
                b"\x1b[1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17;18;19;20;21;22;23;24;25;26;27;28;29;30;31;32;33;34;35;36;37;38;39;40;41;42;43;44;45;46;47;48;49;50m",
                "SGR (Select Graphic Rendition)",
            ),
            (
                b"\x1b[1;2;3;4;5;6;7;8;9;10;11;12;13;14;15;16;17;18;19;20;21;22;23;24;25;26;27;28;29;30;31;32;33;34;35;36;37;38;39;40;41;42;43;44;45;46;47;48;49;50L",
                "IL (Insert Line)",
            ),
        ];

        for (sequence, description) in test_cases {
            // Reset to known position
            let _unused = ofs_buf.apply_ansi_bytes(format!(
                "{}",
                CsiSequence::CursorPosition {
                    row: term_row(nz(5)),
                    col: term_col(nz(5))
                }
            ));

            // Send sequence with excessive parameters
            let _unused = ofs_buf.apply_ansi_bytes(sequence);

            // Position should remain unchanged for cursor commands
            // (For SGR/IL, we just verify no crash)
            if description.contains("Cursor") || description.contains("CUP") {
                assert_eq!(
                    ofs_buf.cursor_pos.row_index,
                    row(4),
                    "{description} should be ignored when params exceed limit"
                );
                assert_eq!(
                    ofs_buf.cursor_pos.col_index,
                    col(4),
                    "{description} should be ignored when params exceed limit"
                );
            }
        }
    }
}
