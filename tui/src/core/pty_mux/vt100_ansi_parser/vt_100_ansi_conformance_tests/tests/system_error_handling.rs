// Copyright (c) 2025 R3BL LLC. Licensed under Apache License, Version 2.0.

//! Tests for ANSI parser error handling and robustness.
//!
//! This module tests the parser's ability to handle malformed sequences,
//! invalid parameters, incomplete sequences, and other error conditions
//! gracefully without crashing or corrupting state.
//!
//! ## Raw Byte Sequences Usage
//!
//! **Important**: This test module intentionally uses raw byte sequences
//! (e.g., `b"\x1b[L"`) instead of our type-safe builders (`CsiSequence`,
//! `EscSequence`, etc.) because:
//!
//! 1. **Malformed sequences cannot be created with type-safe enums** - The builders
//!    enforce valid parameter ranges and proper formatting
//! 2. **Testing parser robustness requires invalid input** - We need to test how the
//!    parser handles sequences that would never be generated by our type-safe code
//! 3. **Real-world robustness** - Applications must handle arbitrary PTY output from
//!    external processes that may contain malformed sequences
//!
//! This is the **only** test module where raw sequences are appropriate.
//! All other tests should use the type-safe builders for maintainability
//! and correctness.
//!
//! ## Error Handling Categories
//! - Malformed CSI sequences with invalid parameters
//! - Incomplete escape sequences
//! - Out-of-bounds values and boundary violations
//! - Invalid UTF-8 sequences and control characters
//! - Mixed valid/invalid sequence combinations
//! - Buffer overflow and performance stress scenarios

use super::super::test_fixtures::*;
use crate::vt100_ansi_parser::{protocols::csi_codes::CsiSequence,
                               term_units::{term_col, term_row}};

/// Tests for malformed CSI sequence handling.
pub mod malformed_csi_sequences {
    use super::*;

    /// Note: Using type-safe `CsiSequence` builders (not raw bytes) because we're testing
    /// bounds clamping behavior with valid sequences that have out-of-bounds parameters.
    /// This differs from malformed sequence tests which need raw bytes for invalid
    /// syntax.
    #[test]
    fn test_invalid_cursor_position_parameters() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Send CSI sequences with invalid parameters
        let malformed_sequences: Vec<&[u8]> = vec![
            b"\x1b[999;999H", // Position far beyond buffer bounds
            b"\x1b[0;0H",     // Zero position (should clamp to 1,1)
            b"\x1b[-5;-10H",  // Negative positions
            b"\x1b[;H",       // Missing parameters
            b"\x1b[1;H",      // Missing second parameter
            b"\x1b[;1H",      // Missing first parameter
        ];

        for sequence in malformed_sequences {
            let _result = ofs_buf.apply_ansi_bytes(sequence);

            // Cursor should remain within valid bounds
            assert!(
                ofs_buf.cursor_pos.row_index < crate::row(10),
                "Cursor row out of bounds after sequence: {:?}",
                std::str::from_utf8(sequence).unwrap_or("invalid UTF-8")
            );
            assert!(
                ofs_buf.cursor_pos.col_index < crate::col(10),
                "Cursor column out of bounds after sequence: {:?}",
                std::str::from_utf8(sequence).unwrap_or("invalid UTF-8")
            );
        }
    }

    #[test]
    fn test_invalid_sgr_parameters() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test SGR sequences with invalid parameters
        let malformed_sgr: Vec<&[u8]> = vec![
            b"\x1b[999m",              // Out-of-range SGR code
            b"\x1b[-1m",               // Negative SGR code
            b"\x1b[m",                 // Missing parameter (should default to reset)
            b"\x1b[38;5;999m",         // Invalid 256-color index
            b"\x1b[38;2;300;300;300m", // RGB values > 255
            b"\x1b[48;5;-1m",          // Negative background color
        ];

        for sequence in malformed_sgr {
            let _result = ofs_buf.apply_ansi_bytes(sequence);

            // Parser should handle gracefully - no crash expected
            // Style state should remain valid
            let style = &ofs_buf.ansi_parser_support.current_style;
            // Basic validity check - style object should be accessible
            let _ = &style.attribs;
        }
    }

    #[test]
    fn test_incomplete_csi_sequences() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test incomplete sequences that might be split across buffer boundaries
        let incomplete_sequences: Vec<&[u8]> = vec![
            b"\x1b[",    // Just CSI introducer
            b"\x1b[2",   // Parameter without terminator
            b"\x1b[1;",  // Parameter with separator but no second param
            b"\x1b[1;2", // Parameters without command character
            b"\x1b[?",   // Private mode marker without rest
        ];

        for sequence in incomplete_sequences {
            let _result = ofs_buf.apply_ansi_bytes(sequence);

            // Should not crash - VTE parser handles incomplete sequences
            // Write some text after to verify parser recovery
            let _result = ofs_buf.apply_ansi_bytes("TEST");
        }
    }

    #[test]
    fn test_csi_with_excessive_parameters() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // CSI sequence with many parameters (stress test parameter parsing)
        let excessive_params = b"\x1b[1;2;3;4;5;6;7;8;9;10;11;12;13;14;15H";
        let _result = ofs_buf.apply_ansi_bytes(excessive_params);

        // Should not crash and cursor should remain in bounds
        assert!(ofs_buf.cursor_pos.row_index < crate::row(10));
        assert!(ofs_buf.cursor_pos.col_index < crate::col(10));
    }

    #[test]
    fn test_unknown_csi_commands() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test unknown CSI command characters
        let unknown_commands: Vec<&[u8]> = vec![
            b"\x1b[1Q",   // Unknown command 'Q'
            b"\x1b[5X",   // Unknown command 'X'
            b"\x1b[?25Y", // Unknown private mode command 'Y'
            b"\x1b[>1Z",  // Unknown secondary DA command 'Z'
        ];

        for sequence in unknown_commands {
            let _result = ofs_buf.apply_ansi_bytes(sequence);

            // Should handle gracefully and allow continued operation
            let _result = ofs_buf.apply_ansi_bytes("OK");
        }
    }
}

/// Tests for malformed OSC sequence handling.
pub mod malformed_osc_sequences {
    use super::*;

    #[test]
    fn test_incomplete_osc_sequences() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test incomplete OSC sequences
        let incomplete_osc: Vec<&[u8]> = vec![
            b"\x1b]",        // Just OSC introducer
            b"\x1b]0",       // OSC code without separator
            b"\x1b]0;",      // OSC code with separator but no data
            b"\x1b]0;title", // OSC without terminator
        ];

        for sequence in incomplete_osc {
            let _result = ofs_buf.apply_ansi_bytes(sequence);

            // Should not crash
            let _result = ofs_buf.apply_ansi_bytes("RECOVERY");
        }
    }

    #[test]
    fn test_osc_with_invalid_codes() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test OSC sequences with invalid codes
        let invalid_osc: Vec<&[u8]> = vec![
            b"\x1b]999;data\x07", // Unknown OSC code
            b"\x1b]-1;data\x07",  // Negative OSC code
            b"\x1b]abc;data\x07", // Non-numeric OSC code
            b"\x1b];data\x07",    // Missing OSC code
        ];

        for sequence in invalid_osc {
            let _result = ofs_buf.apply_ansi_bytes(sequence);

            // Should handle gracefully
            let _result = ofs_buf.apply_ansi_bytes("CONTINUE");
        }
    }

    #[test]
    fn test_osc_with_malformed_parameters() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test OSC hyperlinks with malformed parameters
        let malformed_hyperlinks: Vec<&[u8]> = vec![
            b"\x1b]8;;\x07",                             // Empty URI
            b"\x1b]8;id=test\x07",                       // Missing URI
            b"\x1b]8;id=test;not-a-uri\x07",             // Invalid URI format
            b"\x1b]8;invalid-param;http://test.com\x07", // Malformed parameters
        ];

        for sequence in malformed_hyperlinks {
            let _result = ofs_buf.apply_ansi_bytes(sequence);

            // Should handle gracefully without corrupting state
            let _result = ofs_buf.apply_ansi_bytes("Link text");
        }
    }
}

/// Tests for invalid control characters and UTF-8 handling.
pub mod invalid_character_handling {
    use super::*;

    #[test]
    fn test_invalid_control_characters() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test invalid or unsupported control characters
        let invalid_controls: Vec<&[u8]> = vec![
            b"\x01", // SOH (Start of Header)
            b"\x02", // STX (Start of Text)
            b"\x7F", // DEL (Delete)
            b"\x80", // PAD (Padding Character) - C1 control
            b"\x9F", // APC (Application Program Command)
        ];

        for sequence in invalid_controls {
            let _result = ofs_buf.apply_ansi_bytes(sequence);

            // Should not crash or corrupt state
            let _result = ofs_buf.apply_ansi_bytes("TEST");
        }
    }

    #[test]
    fn test_mixed_valid_invalid_sequences() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Mix valid and invalid sequences
        let mixed_sequence = format!(
            "{}{}{}{}{}",
            "Valid text before",
            "\x1b[999;999H", // Invalid position
            "Text after invalid position",
            "\x1b[38;5;999m", // Invalid color
            "Text after invalid color"
        );

        let _result = ofs_buf.apply_ansi_bytes(mixed_sequence);

        // Should handle mixture gracefully
        assert!(ofs_buf.cursor_pos.row_index < crate::row(10));
        assert!(ofs_buf.cursor_pos.col_index < crate::col(10));
    }

    #[test]
    fn test_rapid_malformed_sequence_stream() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Send many malformed sequences rapidly
        for _ in 0..50 {
            let malformed_batch = format!(
                "{}{}{}{}",
                "\x1b[999H",      // Invalid position
                "\x1b[999m",      // Invalid SGR
                "\x1b]999;x\x07", // Invalid OSC
                "X"               // Valid character
            );
            let _result = ofs_buf.apply_ansi_bytes(malformed_batch);
        }

        // Should maintain stability under stress
        assert!(ofs_buf.cursor_pos.row_index < crate::row(10));
        assert!(ofs_buf.cursor_pos.col_index < crate::col(10));

        // Should still accept valid input
        let _result = ofs_buf.apply_ansi_bytes("FINAL");
    }
}

/// Tests for boundary conditions and edge cases.
pub mod boundary_edge_cases {
    use super::*;

    /// Note: Using type-safe `CsiSequence` builders (not raw bytes) because we're
    /// testing VT100 specification compliance with valid sequences that have
    /// edge-case parameters. Type-safe builders ensure proper sequence
    /// formatting while testing semantic behavior.
    #[test]
    fn test_zero_parameter_treated_as_one() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test VT100-compliant behavior: zero parameters are treated as 1
        // Reset cursor position for each test to ensure independent testing
        let test_cases = vec![
            (
                "Cursor up by 0",
                CsiSequence::CursorUp(0),
                term_row(3),
                term_col(3),
                crate::row(1),
                crate::col(2),
            ),
            (
                "Cursor down by 0",
                CsiSequence::CursorDown(0),
                term_row(3),
                term_col(3),
                crate::row(3),
                crate::col(2),
            ),
            (
                "Cursor forward by 0",
                CsiSequence::CursorForward(0),
                term_row(3),
                term_col(3),
                crate::row(2),
                crate::col(3),
            ),
            (
                "Cursor backward by 0",
                CsiSequence::CursorBackward(0),
                term_row(3),
                term_col(3),
                crate::row(2),
                crate::col(1),
            ),
        ];

        for (
            description,
            movement_cmd,
            start_row,
            start_col,
            expected_row,
            expected_col,
        ) in test_cases
        {
            // Reset cursor to known position for each test
            let _result = ofs_buf.apply_ansi_bytes(format!(
                "{}",
                CsiSequence::CursorPosition {
                    row: start_row,
                    col: start_col
                }
            ));

            // Apply the zero-parameter movement command
            let _result = ofs_buf.apply_ansi_bytes(movement_cmd.to_string());

            // Per VT100 spec: parameter 0 is treated as 1 (minimum movement)
            assert_eq!(
                ofs_buf.cursor_pos.row_index, expected_row,
                "VT100 spec: {description} should move by 1 (row)"
            );
            assert_eq!(
                ofs_buf.cursor_pos.col_index, expected_col,
                "VT100 spec: {description} should move by 1 (col)"
            );
        }
    }

    #[test]
    fn test_maximum_parameter_values() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test with very large parameter values
        let large_params: Vec<&[u8]> = vec![
            b"\x1b[65535;65535H", // Maximum u16 values
            b"\x1b[32767A",       // Large cursor movement
            b"\x1b[999999m",      // Very large SGR code
        ];

        for sequence in large_params {
            let _result = ofs_buf.apply_ansi_bytes(sequence);

            // Should clamp to valid ranges
            assert!(ofs_buf.cursor_pos.row_index < crate::row(10));
            assert!(ofs_buf.cursor_pos.col_index < crate::col(10));
        }
    }

    #[test]
    fn test_buffer_position_clamping() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Test positions beyond buffer boundaries
        let beyond_bounds = vec![
            format!(
                "{}",
                CsiSequence::CursorPosition {
                    row: term_row(50),
                    col: term_col(50)
                }
            ),
            format!(
                "{}",
                CsiSequence::CursorPosition {
                    row: term_row(1),
                    col: term_col(100)
                }
            ),
            format!(
                "{}",
                CsiSequence::CursorPosition {
                    row: term_row(100),
                    col: term_col(1)
                }
            ),
        ];

        for sequence in beyond_bounds {
            let _result = ofs_buf.apply_ansi_bytes(sequence);

            // Positions should be clamped to buffer bounds
            assert!(
                ofs_buf.cursor_pos.row_index <= crate::row(9), /* 0-based, so max is 9
                                                                * for 10-row buffer */
                "Row not clamped properly: {:?}",
                ofs_buf.cursor_pos
            );
            assert!(
                ofs_buf.cursor_pos.col_index <= crate::col(9), /* 0-based, so max is 9
                                                                * for 10-col buffer */
                "Column not clamped properly: {:?}",
                ofs_buf.cursor_pos
            );
        }
    }
}

/// Tests for parser state recovery and resilience.
pub mod parser_resilience {
    use super::*;

    #[test]
    fn test_recovery_after_malformed_sequences() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Send malformed sequences followed by valid ones
        let recovery_test = format!(
            "{}{}{}{}{}",
            "Initial text",
            "\x1b[INVALID",      // Malformed escape
            "\x1b]999MALFORMED", // Malformed OSC
            "Recovery text",     // Should be processed normally
            CsiSequence::CursorPosition {
                row: term_row(2),
                col: term_col(1)
            }
        );

        let _result = ofs_buf.apply_ansi_bytes(recovery_test);

        // Should be able to continue processing after malformed input
        let _result = ofs_buf.apply_ansi_bytes("Final test");

        // Parser should be in a valid state
        assert!(ofs_buf.cursor_pos.row_index < crate::row(10));
        assert!(ofs_buf.cursor_pos.col_index < crate::col(10));
    }

    #[test]
    fn test_partial_sequence_handling() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Simulate partial sequences arriving in separate chunks
        let partial_chunks: Vec<&[u8]> = vec![
            b"\x1b", // ESC alone
            b"[",    // [ to complete CSI introducer
            b"1",    // First parameter digit
            b"0",    // Second parameter digit
            b";",    // Parameter separator
            b"5",    // Second parameter
            b"H",    // Command character
        ];

        // Send chunks separately (simulating network/buffer splits)
        for chunk in partial_chunks {
            let _result = ofs_buf.apply_ansi_bytes(chunk);
        }

        // Should eventually process complete sequence
        assert!(ofs_buf.cursor_pos.row_index < crate::row(10));
        assert!(ofs_buf.cursor_pos.col_index < crate::col(10));
    }

    #[test]
    fn test_state_corruption_prevention() {
        let mut ofs_buf = create_test_offscreen_buffer_10r_by_10c();

        // Try to corrupt parser state with adversarial input
        let adversarial_input = format!(
            "{}{}{}{}{}{}{}",
            "\x1b[s",            // Save cursor
            "\x1b[999;999H",     // Move to invalid position
            "\x1b[999m",         // Invalid SGR
            "\x1b]0;evil\x1b\\", // OSC with early terminator
            "\x1b[u",            // Restore cursor
            "\x1b[H",            // Home
            "State check"        // Normal text
        );

        let _result = ofs_buf.apply_ansi_bytes(adversarial_input);

        // State should remain consistent
        assert!(ofs_buf.cursor_pos.row_index < crate::row(10));
        assert!(ofs_buf.cursor_pos.col_index < crate::col(10));

        // Should still respond to valid commands
        let move_sequence = format!(
            "{}",
            CsiSequence::CursorPosition {
                row: term_row(3),
                col: term_col(3)
            }
        );
        let _result = ofs_buf.apply_ansi_bytes(move_sequence);

        assert_eq!(ofs_buf.cursor_pos.row_index, crate::row(2)); // 0-based
        assert_eq!(ofs_buf.cursor_pos.col_index, crate::col(2)); // 0-based
    }
}
