// Copyright (c) 2025 R3BL LLC. Licensed under Apache License, Version 2.0.

//! Tests for line insertion and deletion operations (IL/DL).

use vte::Perform;

use super::tests_fixtures::*;
use crate::{ansi_parser::{ansi_parser_public_api::AnsiToBufferProcessor,
                          protocols::csi_codes::CsiSequence},
            col, row};

/// Tests for Insert Line (IL) operations.
pub mod insert_line {
    use super::*;

    #[test]
    fn test_insert_single_line() {
        let mut ofs_buf = create_numbered_buffer(5, 10);
        
        // Move cursor to row 2 (0-based) and insert one line
        let move_cursor = CsiSequence::CursorPosition { 
            row: crate::ansi_parser::term_units::TermRow::new(3), 
            col: crate::ansi_parser::term_units::TermCol::new(1)
        }; // Move to row 3, col 1 (1-based)
        let insert_line = CsiSequence::InsertLine(1);
        let sequence = format!("{move_cursor}{insert_line}");
        let _result = ofs_buf.apply_ansi_bytes(sequence);
        
        // Verify lines have shifted down
        assert_blank_line(&ofs_buf, 2);        // New blank line at cursor
        assert_line_content(&ofs_buf, 0, "Line00"); // Line 0 unchanged  
        assert_line_content(&ofs_buf, 1, "Line01"); // Line 1 unchanged
        assert_line_content(&ofs_buf, 3, "Line02"); // Line 2 shifted to 3
        assert_line_content(&ofs_buf, 4, "Line03"); // Line 3 shifted to 4
        // Line 4 ("Line04") was lost (shifted off bottom)
    }

    #[test]
    fn test_insert_multiple_lines() {
        let mut ofs_buf = create_numbered_buffer(5, 10);
        
        // Move cursor to row 1 (0-based) and insert three lines
        let move_cursor = CsiSequence::CursorPosition { 
            row: crate::ansi_parser::term_units::TermRow::new(2), 
            col: crate::ansi_parser::term_units::TermCol::new(1)
        }; // Move to row 2, col 1 (1-based)
        let insert_lines = CsiSequence::InsertLine(3);
        let sequence = format!("{move_cursor}{insert_lines}");
        let _result = ofs_buf.apply_ansi_bytes(sequence);
        
        // Verify lines have shifted down by 3
        assert_line_content(&ofs_buf, 0, "Line00"); // Line 0 unchanged
        assert_blank_line(&ofs_buf, 1);             // New blank lines
        assert_blank_line(&ofs_buf, 2);
        assert_blank_line(&ofs_buf, 3);
        assert_line_content(&ofs_buf, 4, "Line01"); // Line 1 shifted to 4
        // Lines 2, 3, 4 were lost
    }

    #[test]
    fn test_insert_lines_with_margins() {
        let mut ofs_buf = create_numbered_buffer(10, 10);
        let mut processor = AnsiToBufferProcessor::new(&mut ofs_buf);
        
        // Set scroll margins: rows 3-7 (1-based) = 2-6 (0-based)
        processor.ofs_buf.ansi_parser_support.scroll_region_top = 
            Some(crate::ansi_parser::term_units::TermRow::from_one_based(3));
        processor.ofs_buf.ansi_parser_support.scroll_region_bottom = 
            Some(crate::ansi_parser::term_units::TermRow::from_one_based(7));
        
        // Move cursor to row 4 (0-based, within margins)
        processor.ofs_buf.my_pos = row(4) + col(0);
        
        // Insert one line: ESC[L
        processor.csi_dispatch(&[], &[], false, 'L');
        
        // Verify only lines within margins are affected
        assert_line_content(&ofs_buf, 0, "Line00"); // Outside margins, unchanged
        assert_line_content(&ofs_buf, 1, "Line01"); // Outside margins, unchanged
        assert_line_content(&ofs_buf, 2, "Line02"); // Top margin, unchanged
        assert_line_content(&ofs_buf, 3, "Line03"); // Within margins, unchanged
        assert_blank_line(&ofs_buf, 4);             // Inserted blank line
        assert_line_content(&ofs_buf, 5, "Line04"); // Shifted within margins
        assert_line_content(&ofs_buf, 6, "Line05"); // Shifted within margins
        // Line06 was lost at bottom of scroll region
        assert_line_content(&ofs_buf, 7, "Line07"); // Outside margins, unchanged
        assert_line_content(&ofs_buf, 8, "Line08"); // Outside margins, unchanged
        assert_line_content(&ofs_buf, 9, "Line09"); // Outside margins, unchanged
    }

    #[test]
    fn test_insert_line_outside_margins_ignored() {
        let mut ofs_buf = create_numbered_buffer(5, 10);
        let mut processor = AnsiToBufferProcessor::new(&mut ofs_buf);
        
        // Set scroll margins: rows 2-4 (1-based) = 1-3 (0-based)
        processor.ofs_buf.ansi_parser_support.scroll_region_top = 
            Some(crate::ansi_parser::term_units::TermRow::from_one_based(2));
        processor.ofs_buf.ansi_parser_support.scroll_region_bottom = 
            Some(crate::ansi_parser::term_units::TermRow::from_one_based(4));
        
        // Move cursor to row 0 (outside margins)
        processor.ofs_buf.my_pos = row(0) + col(0);
        
        // Try to insert line: ESC[L (should be ignored)
        processor.csi_dispatch(&[], &[], false, 'L');
        
        // Verify no changes occurred
        for r in 0..5 {
            assert_line_content(&ofs_buf, r, &format!("Line{:02}", r));
        }
    }
}

/// Tests for Delete Line (DL) operations.
pub mod delete_line {
    use super::*;

    #[test]
    fn test_delete_single_line() {
        let mut ofs_buf = create_numbered_buffer(5, 10);
        let mut processor = AnsiToBufferProcessor::new(&mut ofs_buf);
        
        // Move cursor to row 2 (0-based)
        processor.ofs_buf.my_pos = row(2) + col(0);
        
        // Delete one line: ESC[M
        processor.csi_dispatch(&[], &[], false, 'M');
        
        // Verify lines have shifted up
        assert_line_content(&ofs_buf, 0, "Line00"); // Line 0 unchanged
        assert_line_content(&ofs_buf, 1, "Line01"); // Line 1 unchanged
        assert_line_content(&ofs_buf, 2, "Line03"); // Line 3 shifted to 2
        assert_line_content(&ofs_buf, 3, "Line04"); // Line 4 shifted to 3
        assert_blank_line(&ofs_buf, 4);             // New blank line at bottom
        // Line 2 ("Line02") was deleted
    }

    #[test]
    fn test_delete_multiple_lines() {
        let mut ofs_buf = create_numbered_buffer(5, 10);
        let mut processor = AnsiToBufferProcessor::new(&mut ofs_buf);
        
        // Move cursor to row 1 (0-based)
        processor.ofs_buf.my_pos = row(1) + col(0);
        
        // Delete three lines: ESC[3M
        let params = vte::Params::new(&[3_u16], &[]);
        processor.csi_dispatch(&params, &[], false, 'M');
        
        // Verify lines have shifted up by 3
        assert_line_content(&ofs_buf, 0, "Line00"); // Line 0 unchanged
        assert_line_content(&ofs_buf, 1, "Line04"); // Line 4 shifted to 1
        assert_blank_line(&ofs_buf, 2);             // New blank lines at bottom
        assert_blank_line(&ofs_buf, 3);
        assert_blank_line(&ofs_buf, 4);
        // Lines 1, 2, 3 were deleted
    }

    #[test]
    fn test_delete_lines_with_margins() {
        let mut ofs_buf = create_numbered_buffer(10, 10);
        let mut processor = AnsiToBufferProcessor::new(&mut ofs_buf);
        
        // Set scroll margins: rows 3-7 (1-based) = 2-6 (0-based)
        processor.ofs_buf.ansi_parser_support.scroll_region_top = 
            Some(crate::ansi_parser::term_units::TermRow::from_one_based(3));
        processor.ofs_buf.ansi_parser_support.scroll_region_bottom = 
            Some(crate::ansi_parser::term_units::TermRow::from_one_based(7));
        
        // Move cursor to row 4 (0-based, within margins)
        processor.ofs_buf.my_pos = row(4) + col(0);
        
        // Delete one line: ESC[M
        processor.csi_dispatch(&[], &[], false, 'M');
        
        // Verify only lines within margins are affected
        assert_line_content(&ofs_buf, 0, "Line00"); // Outside margins, unchanged
        assert_line_content(&ofs_buf, 1, "Line01"); // Outside margins, unchanged
        assert_line_content(&ofs_buf, 2, "Line02"); // Top margin, unchanged
        assert_line_content(&ofs_buf, 3, "Line03"); // Within margins, unchanged
        assert_line_content(&ofs_buf, 4, "Line05"); // Line05 shifted to 4
        assert_line_content(&ofs_buf, 5, "Line06"); // Line06 shifted to 5
        assert_blank_line(&ofs_buf, 6);             // New blank line at bottom of region
        assert_line_content(&ofs_buf, 7, "Line07"); // Outside margins, unchanged
        assert_line_content(&ofs_buf, 8, "Line08"); // Outside margins, unchanged
        assert_line_content(&ofs_buf, 9, "Line09"); // Outside margins, unchanged
        // Line04 was deleted
    }

    #[test]
    fn test_delete_line_outside_margins_ignored() {
        let mut ofs_buf = create_numbered_buffer(5, 10);
        let mut processor = AnsiToBufferProcessor::new(&mut ofs_buf);
        
        // Set scroll margins: rows 2-4 (1-based) = 1-3 (0-based)
        processor.ofs_buf.ansi_parser_support.scroll_region_top = 
            Some(crate::ansi_parser::term_units::TermRow::from_one_based(2));
        processor.ofs_buf.ansi_parser_support.scroll_region_bottom = 
            Some(crate::ansi_parser::term_units::TermRow::from_one_based(4));
        
        // Move cursor to row 4 (outside margins)
        processor.ofs_buf.my_pos = row(4) + col(0);
        
        // Try to delete line: ESC[M (should be ignored)
        processor.csi_dispatch(&[], &[], false, 'M');
        
        // Verify no changes occurred
        for r in 0..5 {
            assert_line_content(&ofs_buf, r, &format!("Line{:02}", r));
        }
    }
}