# Claude Code Instructions for r3bl-open-core

## Task Tracking System

This project uses a two-file task tracking system to maintain project state and history:

### 1. todo.md - Active Work File

- **Check this file at the start of each session** to understand current project state
- The most recent changes are always at the top
- Update task checkboxes `[x]` immediately when completing tasks
- Keep partially completed sections here (with mixed `[x]` and `[ ]` items)
- Add newly discovered tasks to appropriate sections
- Maintain task hierarchy with proper indentation for subtasks

### 2. done.md - Archive File

- Contains completed feature sets and milestones
- The most recent changes are always at the bottom
- Move **entire sections** here only when ALL subtasks are complete
- When moving sections always put the latest changes at the top of the file, so the latest change is
  always at the top, and the previous changes are below it for historical reference
- Include the section header and all its subtasks when moving
- This serves as the project's historical record

### When to Move Tasks from todo.md to done.md

- Only move complete sections where ALL subtasks show `[x]`. Move the entire completed section to
  the bottom of done.md
- Never move individual tasks - preserve context by keeping related tasks together
- Example: The "fix md parser" section should only move after all 200+ subtasks are complete

### Task Format Guidelines

- Use `- [x]` for completed tasks
- Use `- [ ]` for pending tasks
- Group related tasks under descriptive headers with `#` or plain text
- Include GitHub issue links where relevant (e.g.,
  `https://github.com/r3bl-org/r3bl-open-core/issues/397`)
- Add technical notes, code snippets, or implementation details for complex tasks
- Use consistent indentation (2 spaces) for subtasks

### Benefits of This System

- todo.md remains focused and manageable (<300 lines)
- Historical progress is preserved in done.md
- Active work stays visible with full context
- Easy to track what's been accomplished vs what remains

## Additional Project Guidelines

### MCP servers

- Use `rust-analyzer` MCP server tool to efficiently work with analyzing and refactoring Rust source
  files
- Use `context7` MCP server tool to look up documentation on Rust crates

### Code Quality

- Run typecheck, test, and lint commands after completing tasks:
  - Fast compiler typecheck command is `cargo check`
  - Detailed lint check is `cargo clippy --all-targets`, and to fix them use
    `cargo clippy --fix --allow-dirty`
  - Fix doc errors and warnings generated by `cargo doc --no-deps`
  - Test check is `cargo nextest run`
  - Ask user for the correct commands if unable to find them
  - Suggest adding these commands to this file for future reference

- For performance analysis, use:
  - Use `cargo bench` for benchmarks. Add bench tests in the file with the code under test and mark
    with `#[bench]`
  - For the latest flamegraph analysis from the `tui/flamegraph.perf-folded` file
  - Ask the user to generate this file by running `run_example_with_flamegraph_profiling_perf_fold`
    in `lib_script.nu` for interactive TUI apps. For non interactive apps, you can run it yourself
    using `cargo flamegraph`
  - `cargo flamegraph` for flamegraph profiling
  - Ask user for the correct commands if unable to find them

### Git Workflow

- Never commit changes unless explicitly asked by the user
- This prevents overly proactive behavior that might disrupt the user's workflow
